
var documents = [{
    "id": 0,
    "url": "https://vikassharma.me/v1/404.html",
    "title": "404",
    "body": "404Page does not exist!Please use the search bar at the top or visit our homepage! "
    }, {
    "id": 1,
    "url": "https://vikassharma.me/v1/about/",
    "title": "About",
    "body": "As a seasoned software engineer with over a decade of experience, I’ve had the privilege of contributing to renowned companies, honing my skills, and building a robust foundation in software development. My expertise spans various technologies, including Python, C#, React, Redis, and a range of SQL databases (PostgreSQL, MySQL, MSSQL). This breadth of knowledge equips me to architect, develop, and deliver high-quality software solutions in domains such as payments, fintech, healthcare, and more. Throughout my career, I’ve excelled in both front-end and back-end development, establishing myself as a versatile full-stack engineer. My commitment to creating innovative and efficient solutions is deeply rooted in a comprehensive understanding of microservices architecture, enabling me to design scalable, distributed, highly available, and robust applications that consistently meet and exceed business goals. I thrive on tackling complex technical challenges, collaborating with cross-functional teams, and mentoring junior engineers. My track record includes successfully leading pivotal projects, implementing best practices, and optimizing software development processes for enhanced efficiency and quality. Apart from work, I like to play guitar and occasionally go on road trips. Resume: View | Download       "
    }, {
    "id": 2,
    "url": "https://vikassharma.me/v1/blog",
    "title": "Blog",
    "body": "      Featured:                                                                                                                                                                                                                                                                                                                     How to solve Sliding Window Problems                              :                                                                     25 Oct 2023                                                                                                                                                                                                                                                                                                                ReactJs reference notes                              :                                                                     12 Oct 2023                                                                                                                                                                                                                                                                                                          121. Best Time to Buy and Sell Stock                              :                                                                     18 Sep 2023                                                                                                                                                                                                                                                                                                          217. Contains Duplicate                              :                                                                     16 Sep 2023                                                                                                                                                                                                                                                                                                          Understanding Regular Expressions in Python                              :                             Regular expressions, often abbreviated as regex, are a powerful tool used to match patterns in strings. They are widely used in various programming languages, including. . . :                                                                     22 Mar 2023                                                                                                                                                                                                                                                                                                          How to create blog with Jekyll and Github pages                              :                             If you always wanted to start your blog and don’t know where to start. Well, just follow this quick guide and by the end of. . . :                                                                     12 Nov 2022                                                                                                                All Stories:                                                                     Use of `args` and `kwargs` in Python              :                             23 Feb 2025                                                                                    Requests Library Deep Dive - 10              :                             16 Jan 2025                                                                                    Requests Library Deep Dive - 9              :                             15 Jan 2025                                                                                    Usage of cache-control headers and their values              :                             14 Jan 2025                                                                                    Requests Library Deep Dive - 8              :                             13 Jan 2025                                                                                    Requests Library Deep Dive - 7              :                             12 Jan 2025                                                                                    Requests Library Deep Dive - 6              :                             11 Jan 2025                                                                                    Requests Library Deep Dive - 5              :                             10 Jan 2025                                                                                    Requests Library Deep Dive - 4              :                             09 Jan 2025                                                                                    TIL: Python context manager              :                             08 Jan 2025                                                                                    Requests Library Deep Dive - 3              :                             07 Jan 2025                                                                                    Requests Library Deep Dive - 2              :                             06 Jan 2025                                                                                    Requests Library Deep Dive - 1              :                             05 Jan 2025                                                                                    Requests library deep dive series              :                             04 Jan 2025                                                                                    Reflecting on the year 2024              :                             03 Jan 2025                                                                                                                                                            How to solve Sliding Window Problems              :                             25 Oct 2023                                                                                                                                            ReactJs reference notes              :                             12 Oct 2023                                                                                                                            121. Best Time to Buy and Sell Stock              :                             18 Sep 2023                                                                                                                            217. Contains Duplicate              :                             16 Sep 2023                                                                                                                            Understanding Regular Expressions in Python              :             Regular expressions, often abbreviated as regex, are a powerful tool used to match patterns in strings. They are widely used in various programming languages, including Python, for various purposes such. . . :                             22 Mar 2023                                                                                                                            How to create blog with Jekyll and Github pages              :             If you always wanted to start your blog and don’t know where to start. Well, just follow this quick guide and by the end of this article, you’ll have your. . . :                             12 Nov 2022                                                                                                                            Hello world!              :             Excited to share my thoughts here. It’s my birthday today and I thought it would be a good time to start something new and exciting. :                             18 Oct 2022                            "
    }, {
    "id": 3,
    "url": "https://vikassharma.me/v1/categories",
    "title": "Categories",
    "body": ""
    }, {
    "id": 4,
    "url": "https://vikassharma.me/v1/",
    "title": "Home",
    "body": "                           Hi, I am         Vikas Sharma        Software Engineer                  Python | C# | JavaScript | Node | React | Angular | MySQL | Postgres | CI/CD | Docker | AWS                                                                                                                                                            Latest:                                                                     Use of `args` and `kwargs` in Python              :                             23 Feb 2025                                                                                    Requests Library Deep Dive - 10              :                             16 Jan 2025                                                                                    Requests Library Deep Dive - 9              :                             15 Jan 2025                                                                                    Usage of cache-control headers and their values              :                             14 Jan 2025                                                                                    Requests Library Deep Dive - 8              :                             13 Jan 2025                                                                                    Requests Library Deep Dive - 7              :                             12 Jan 2025                                                                                    Requests Library Deep Dive - 6              :                             11 Jan 2025                                                                                    Requests Library Deep Dive - 5              :                             10 Jan 2025                                                                                    Requests Library Deep Dive - 4              :                             09 Jan 2025                                                                                    TIL: Python context manager              :                             08 Jan 2025                                                                                    Requests Library Deep Dive - 3              :                             07 Jan 2025                                                                                    Requests Library Deep Dive - 2              :                             06 Jan 2025                                                                                    Requests Library Deep Dive - 1              :                             05 Jan 2025                                                                                    Requests library deep dive series              :                             04 Jan 2025                                                                                    Reflecting on the year 2024              :                             03 Jan 2025                                                                                                                                                        How to solve Sliding Window Problems              :                             25 Oct 2023                                                                                                                                          ReactJs reference notes              :                             12 Oct 2023                                                                                                                            121. Best Time to Buy and Sell Stock              :                             18 Sep 2023                                                                                                                            217. Contains Duplicate              :                             16 Sep 2023                                                                                                                            Understanding Regular Expressions in Python              :             Regular expressions, often abbreviated as regex, are a powerful tool used to match patterns in strings. They are widely used in various programming languages, including Python, for various purposes such. . . :                             22 Mar 2023                                                                                                                            How to create blog with Jekyll and Github pages              :             If you always wanted to start your blog and don’t know where to start. Well, just follow this quick guide and by the end of this article, you’ll have your. . . :                             12 Nov 2022                                                                                                                            Hello world!              :             Excited to share my thoughts here. It’s my birthday today and I thought it would be a good time to start something new and exciting. :                             18 Oct 2022                                     &laquo; Prev       1        2        3        4        5      Next &raquo;   "
    }, {
    "id": 5,
    "url": "https://vikassharma.me/v1/resume/",
    "title": "Resume - Vikas Sharma",
    "body": "Download "
    }, {
    "id": 6,
    "url": "https://vikassharma.me/v1/robots.txt",
    "title": "",
    "body": "      Sitemap: {{ “sitemap. xml”   absolute_url }}   "
    }, {
    "id": 7,
    "url": "https://vikassharma.me/v1/page2/",
    "title": "Home",
    "body": "                           Hi, I am         Vikas Sharma        Software Engineer                  Python | C# | JavaScript | Node | React | Angular | MySQL | Postgres | CI/CD | Docker | AWS                                                                                                                                                            Latest:         {% for post in site. posts %}      {% if post. dont_list_on_dashboard == true %}        {% continue %}      {% endif %}      {% include postbox. html %}    {% endfor %}          {% include pagination. html %}  "
    }, {
    "id": 8,
    "url": "https://vikassharma.me/v1/page3/",
    "title": "Home",
    "body": "                           Hi, I am         Vikas Sharma        Software Engineer                  Python | C# | JavaScript | Node | React | Angular | MySQL | Postgres | CI/CD | Docker | AWS                                                                                                                                                            Latest:         {% for post in site. posts %}      {% if post. dont_list_on_dashboard == true %}        {% continue %}      {% endif %}      {% include postbox. html %}    {% endfor %}          {% include pagination. html %}  "
    }, {
    "id": 9,
    "url": "https://vikassharma.me/v1/page4/",
    "title": "Home",
    "body": "                           Hi, I am         Vikas Sharma        Software Engineer                  Python | C# | JavaScript | Node | React | Angular | MySQL | Postgres | CI/CD | Docker | AWS                                                                                                                                                            Latest:         {% for post in site. posts %}      {% if post. dont_list_on_dashboard == true %}        {% continue %}      {% endif %}      {% include postbox. html %}    {% endfor %}          {% include pagination. html %}  "
    }, {
    "id": 10,
    "url": "https://vikassharma.me/v1/page5/",
    "title": "Home",
    "body": "                           Hi, I am         Vikas Sharma        Software Engineer                  Python | C# | JavaScript | Node | React | Angular | MySQL | Postgres | CI/CD | Docker | AWS                                                                                                                                                            Latest:         {% for post in site. posts %}      {% if post. dont_list_on_dashboard == true %}        {% continue %}      {% endif %}      {% include postbox. html %}    {% endfor %}          {% include pagination. html %}  "
    }, {
    "id": 11,
    "url": "https://vikassharma.me/v1/args-and-kwargs-in-python/",
    "title": "Use of `args` and `kwargs` in Python",
    "body": "2025/02/23 - *args and **kwargs allows us to pass multiple arguments and keyword arguments to a function. args: The use of * in front of a collection will unpack it. This interesting behaviour can be used to make your function accept any arbitrary number of parameters. For example, let’s consider a function that concatenates the words passed into a complete sentence separated by space.  First case, where you want to support two words12345def change_words_to_sentence(word_1, word_2):  return f'{word_1} {word_2}'# change_words_to_sentence('Hi', 'there')# output: 'Hi there' Now let’s say you to support more than two words,123456def change_words_to_sentence(words):  return ' '. join(words)# change_words_to_sentence(['Hi', 'there', 'I', 'am', 'learning', 'python'])# output: 'Hi there I am learning python' One another possible way could be,123456def change_words_to_sentence(*args):  return ' '. join(args)# change_words_to_sentence('Hi', 'there', 'I', 'am', 'learning', 'python')# output: 'Hi there I am learning python'Point to note is the name *args is not important, you can use for example *words as well. It basically unpacks the arguments. Unpacking operator * kwargs: It’s very similar to args only main difference being that it can be applied only to dictionaries. For example, 123456def change_words_to_sentence(*kwargs):  return ' '. join(kwargs. values())# change_words_to_sentence(a='Hi', b='there', c='!')# output: 'Hi there !' Notice the use of kwargs. values(), it gives the list of values in the dictionary. Basically, any dictionary methods can be used on kwargs.  Again, kwargs can be replaced by any other name of your choice. Main thing is the operator **. "
    }, {
    "id": 12,
    "url": "https://vikassharma.me/v1/requests-library-deep-dive-10/",
    "title": "Requests Library Deep Dive - 10",
    "body": "2025/01/16 - Continuing the study of the requests module. Today, I am diving into requests/status_codes. py, a relatively small but useful module that deals with HTTP status codes. It maps numerical HTTP status codes to their textual representations, making the library more human-readable and user-friendly. Key Concepts in requests/status_codes. py: Purpose: This module provides a dictionary and helper functions for working with HTTP status codes. It makes it easier to understand and handle status codes by providing textual descriptions. The codes Dictionary: Maps HTTP status codes (e. g. , 200, 404) to their textual descriptions (e. g. , ok, not_found). 123456789101112codes = LookupDict(name='status_codes')# example entries_codes = {  200: 'ok',  404: 'not_found',  500: 'internal_server_error',}for code, phrase in _codes. items():  codes[phrase] = code  codes[code] = [phrase]Two-way mapping:You can look up either by number or by name: 12345from requests. status_codes import codescodes[200]# 'ok'codes['not_found']# 404The LookupDict Class: A custom dictionary implmentation that provides case-insensitive lookup for textual representations of status codes. Key methods:  __getitem__: Enables standard dictionary access.  get: Fetches a value while handling missing keys gracefully. Example: 123456789101112class LookupDict(dict):  def __init__(self, name=None):    self. name = name  def __getitem__(self, key):    try:      return dict. __getitem__(self, key)    except KeyError:      return self. __missing__(key)  def get(self, key, default=None):    return self[key] if key in self else defaultConvenience in Code: Using this module makes it easier to write clear and readable code when dealing with status codes: 12345678import requestsresponse = requests. get('https://example. com')if response. status_code == requests. codes. ok:  print( The request was successful! )elif response. status_code == requests. codes. not_found:  print( The requested resource was not found.  )"
    }, {
    "id": 13,
    "url": "https://vikassharma.me/v1/requests-library-deep-dive-9/",
    "title": "Requests Library Deep Dive - 9",
    "body": "2025/01/15 - Continuing the study of the requests module. Today, I am diving into requests/exceptions. py, which defines custom exception classes. These exceptions improve error handling and debugging by providing meaningful messages specific to HTTP requests and responses. Key Concepts in requests/exceptions. py: Purpose: requests uses its own set of exceptions to clearly indicate different types of errors, rather than relying on generic Python exceptions like ValueError or OSError. Hierarchy of Exceptions: All exceptions in requests inherit from RequestException. This allows users to catch all exceptions with a single base class if needed. The Base Class: RequestException:  This is the parent class for all exceptions in requests.  It accepts a custom message and optionally a request or response object for additional context. Example: 12345class RequestException(IOError):  def __init__(self, message, request=None, response=None):    super(). __init__(message)    self. request = request    self. response = responseCommon Exceptions: HTTPErrorRaised when an HTTP request fails due to client-side (4xx) or server-side (5xx) errors. It’s often triggered by Response. raise_for_status(). 12class HTTPError(RequestException):  passConnectionErrorRaised when a connection to the server cannot be established. 12class ConnectionError(RequestException):  passTimeoutRaised when a request exceeds the specified timeout. 12class Timeout(RequestException):  passURLRequiredRaised when a URL is not provided to a request. 12class URLRequired(RequestException):  passTooManyRedirectsRaised when the maximum number of allowed redirects is exceeded. 12class TooManyRedirects(RequestException):  passInvalidURLRaised when a URL is improperly formatted. 12class InvalidURL(RequestException):  passLess Common Exceptions: ProxyErrorRaised when a request fails due to issues with a proxy server. 12class ProxyError(ConnectionError):  passSSLErrorRaised for SSL/TLS-related errors, such as certificate validation failures. 12class SSLError(ConnectionError):  passChunkedEncodingErrorRaised when the server provides malformed chunked encoding data. 12class ChunkedEncodingError(RequestException):  passContentDecodingErrorRaised when the response body cannot be decoded. 12class ContentDecodingError(RequestException):  passUsage in Code: Exception handling is simplified because of this module. For example: 123456789101112import requeststry:  response = requests. get('https://example. com', timeout=1)  response. raise_for_status() # Raises HTTPError for 4xx/5xx responsesexcept requests. exceptions. Timeout:  print( Request timed out.  )except requests. exceptions. HTTPError as err:  print(f HTTP error occurred: {err} )except requests. exceptions. RequestException as err:  print(f An error occurred: {err} )"
    }, {
    "id": 14,
    "url": "https://vikassharma.me/v1/usage-of-cache-control-headers/",
    "title": "Usage of cache-control headers and their values",
    "body": "2025/01/14 - Cache-Control Headers and Their UsageThe Cache-Control HTTP header is crucial for managing caching mechanisms for both browsers and Content Delivery Networks (CDNs). It specifies how and for how long a resource should be cached. Common Directives and Their Meanings:  max-age: Specifies the maximum time (in seconds) a resource is considered fresh.      Example: Cache-Control: max-age=3600 (cache for 1 hour).     s-maxage: Similar to max-age, but applies only to shared caches (e. g. , CDNs or reverse proxies).      Overrides max-age for shared caches if both are present.    Example: Cache-Control: max-age=3600, s-maxage=7200 (1 hour for browsers, 2 hours for shared caches).     Other common directives:     no-cache: Forces caches to revalidate the resource with the origin server before serving.    no-store: Prevents caching entirely.    public: Indicates the resource can be cached by any cache.    private: Restricts caching to the browser only.    must-revalidate: Requires caches to revalidate the resource when it becomes stale.    Browser TTL vs. CDN TTL:  Browser TTL:     Controlled by max-age.    Specifies how long the browser should cache a resource locally.    Example: Cache-Control: max-age=3600 (the browser caches the resource for 1 hour).     CDN TTL:     Controlled by s-maxage.    Defines how long a CDN or shared cache should hold the resource.    Overrides max-age for shared caches.    Example: Cache-Control: max-age=3600, s-maxage=7200 (CDN caches for 2 hours, browser caches for 1 hour).    Setting Browser Cache to 10 Seconds and CDN Cache to 60 Seconds: To set different caching times for the browser and CDN:  Use max-age=10 for the browser.  Use s-maxage=60 for the CDN. Example Header:: 1Cache-Control: max-age=10, s-maxage=60 The browser will cache the resource for 10 seconds.  The CDN will cache the resource for 60 seconds before revalidating with the origin server. Key Differences Between Browser and CDN Caching:  Scope: max-age applies to browsers and shared caches unless overridden by s-maxage. s-maxage is exclusive to shared caches.  Hierarchy: Shared caches (like CDNs) prioritize s-maxage over max-age.  Purpose: Browser TTL ensures user-specific caching; CDN TTL optimizes resource delivery across a network. Best Practices:  Use s-maxage for precise control over CDN caching and max-age for browser caching.  For frequently updated resources, consider must-revalidate or no-cache.  Combine Cache-Control with ETag or Last-Modified for conditional requests. Additional Considerations for Effective Caching:  Cache Invalidation:Ensure you have a strategy to invalidate cached resources when the content changes. This can be done by:     Versioning URLs (e. g. , appending ?v=1. 2).    Using ETag and Last-Modified headers to help caches determine freshness.       Mixing Private and Public Resources:Use private for user-specific content (e. g. , account details) and public for shared content (e. g. , images, scripts).     Avoid Over-Caching Critical Resources:Resources that change frequently (e. g. , APIs or dynamic content) should have shorter TTLs or use no-cache to avoid stale data.   Testing and Debugging:     Use browser developer tools to inspect cache behavior.    Verify CDN configurations to ensure s-maxage is being respected.     Optimize TTL Settings:Balance between cache freshness and resource delivery speed. For example:     Use longer TTLs for static assets like images, stylesheets, and JavaScript files.    Use shorter TTLs for dynamic or frequently changing content.    When to Use Specific Cache-Control Settings:       Use Case   Cache-Control Example   Notes         Static assets   Cache-Control: max-age=31536000, immutable   Long TTL with immutable ensures assets don’t change unexpectedly.        APIs with dynamic responses   Cache-Control: no-cache, must-revalidate   Ensures responses are always validated before use.        Short browser, long CDN caching   Cache-Control: max-age=10, s-maxage=60   Helps balance frequent updates with CDN efficiency.        Prevent all caching   Cache-Control: no-store   Suitable for sensitive or non-cacheable data.        Mixed private/public content   Cache-Control: private, max-age=60   Restricts caching to the user’s browser only.    By tailoring your caching strategy using Cache-Control headers, you can optimize both performance and freshness for your users and shared caches. "
    }, {
    "id": 15,
    "url": "https://vikassharma.me/v1/requests-library-deep-dive-8/",
    "title": "Requests Library Deep Dive - 8",
    "body": "2025/01/13 - Continuing the study of the requests module. Today, I am diving into requests/hooks. py, a lightweight but powerful module that allows users to attach custom logic to the request/response lifecycle. Key Concepts in requests/hooks. py: Purpose: Hooks provide a way to execute user-defined functions during specific parts of the requests/response lifecycle. This makes it possible to customize or extend the behavior of requests without modifying its core code. Hook Events:  The primary hook event is response, which lets you manipulate or inspect the Response object before it is returned to the user. Structure of Hooks: default_hooks: Defines the default structure of hooks. 1default_hooks = {'response': []}Each key corresponds to a specific lifecycle event, and the value is a list of functions to be executed. Dispatching Hooks: dispatch_hooks: This function executes all functions associated with a specific hook. 12345def dispatch_hook(key, hooks, hook_data, **kwargs):  if hooks. get(key):    for hook in hooks[key]:      hook_data = hook(hook_data, **kwargs)  return hook_data key: The hook event (e. g. , 'response').  hooks: A dictionary containing user-defined hooks.  hook_data: The data passed to the hook (e. g. , a Response object).  kwargs: Optional additional arguments. Using Hooks with Response: Hooks are typically used to inspect or modify a Response before it’s returned to the user. For example: 12345678import requestsdef response_hook(response, *args, **kwargs):  print(f'Hook: Status Code - {response. status_code}')  return responsehooks = {'response': [response_hook]}response = requests. get('https://example. com', hooks=hooks) The response_hook function runs after the request is completed but before the Response is returned.  You can add multiple hooks to the response event, and they will be executed in order. "
    }, {
    "id": 16,
    "url": "https://vikassharma.me/v1/requests-library-deep-dive-7/",
    "title": "Requests Library Deep Dive - 7",
    "body": "2025/01/12 - Continuing the study of the requests module. Today, I am diving into requests/utils. py, which contains common utility functions that are used throughout the library. Key Concepts in requests/utils. py: Purpose: This module provides helper functions for various tasks, such as:  Parsing and formatting urls.  Encoding/Decoding data.  Inspecting request/reponse content. Url related utilities: to_native_string: Ensures that strings are in the correct format for URLs (unicode for Python 3 and bytes for Python 2). 1234def to_native_string(string, encoding='ascii'):  if isinstance(string, bytes):    return string. decode(encoding)  return stringget_environ_proxies: Fetches proxy settings from environment variables like HTTP_PROXY and HTTPS_PROXY. 123456def get_environ_proxies(url, no_proxy=None):  proxies = {}  if should_bypass_proxies(url, no_proxy=no_proxy):    return proxies  . . .   return proxiesThis function ensures that requests respects system-wide proxy configurations. parse_url: Parses a URL into its components (scheme, host, path etc. ) using urlparse from python’s urllib. parse. Encoding Utilities: get_encoding_from_headers: Detect encoding of a response from its Content-Type headers. 123456def get_encoding_from_headers(headers):  content_type = headers. get('content-type')  if not content_type:    return None  match = _charset_from_content_type(content_type)  return match. lower() if match else Noneget_json_utf: Attempts to guess the encoding of a JSON response if not explicitly specified. Content-Type Utilities: get_content_type: Determines the MIME type of a file based on its extension (e. g. , . html -&gt; text/html). Request/Response Inspection Utilities: check_header_validity: Validates the format of HTTP headers to ensure they conform to RFC standards. 123def check_header_validity(header):  if not isinstance(header, str) or '\n' in header or '\r' in header:    raise InvalidHeader( Header value must be a string and must not contain newlines.  )parse_header_links: Parses Link headers (commonly used in APIs for pagination) 1234567def parse_header_links(value):  links = []  replace_chars = ' \' '  for val in value. split( , ):    . . .     links. append({ url : url,  rel : rel})  return links"
    }, {
    "id": 17,
    "url": "https://vikassharma.me/v1/requests-library-deep-dive-6/",
    "title": "Requests Library Deep Dive - 6",
    "body": "2025/01/11 - Continuing the study of the requests module. Today, I am diving into requests/adapters. py, which implements the low-level connection management and is crucial for handling HTTP requests efficiently. Key Concepts in requests/adapters. py: The HTTPAdapter Class: The HTTPAdapter class is responsible for:  Handling connections (e. g. , opening, reusing and closing).  Managing retries and timeouts.  Sending the actual http requests using urllib3, which is a dependency of requests. Key Attributes of Session:  poolmanager: Manages connection pools for reusing the connections to the same host.  max_retries: Defines how many times to retry a failed request.  timeout: Sets a default timeout for requests if not provided explicitly.   1234567def __init__(self, pool_connections=10, pool_maxsize=10, max_retries=3, pool_block=False): self. max_retries = max_retries self. poolmanager = PoolManager(   num_pools=pool_connections,   maxsize=pool_maxsize,   block=pool_block, )    PoolManager is a feature of urllib3 that handles connection pooling. Sending a request: The send method is the core of the HTTPAdapter class. It sends a PreparedRequest and returns a Response object. Key Steps Inside send:  Get connection:A connection from a pool is fetched using PoolManager.   1conn = self. poolmanager. connection_from_url(request. url)    Make the request:The actual HTTP request is made via conn. urlopen, which comes from urllib3.   12345678response = conn. urlopen( method=request. method, url=request. url, body=request. body, headers=request. headers, retries=self. max_retries, timeout=timeout,)    Wrap the response:The raw urllib3 response is wrapped in a Response object.   1response = self. build_response(request, response)   Adapter lifecycle:  Each Session object has a dictionary mapping schemes (like http and https) to HTTPAdapter instances:1self. adapters = {'http://': HTTPAdapter(), 'https://': HTTPAdapter()} When a Session sends a request, it looks up the adapter for the request’s URL scheme.   1234def get_adapter(self, url): for prefix, adapter in self. adapters. items():   if url. lower(). startswith(prefix):     return adapter   Why Connection Pooling matters:  Without connection pooling, every HTTP request would require a new TCP connection, which is expensive.  By reusing TCP connections for requests to the same host, the HTTPAdapter significantly improves performance, especially for APIs or websites with multiple requests. "
    }, {
    "id": 18,
    "url": "https://vikassharma.me/v1/requests-library-deep-dive-5/",
    "title": "Requests Library Deep Dive - 5",
    "body": "2025/01/10 - Continuing the study of the requests module. Today, I am diving into requests/sessions. py, one of the most important modules in the library. It handles persistent settings and provides the reusable Session object. Key Concepts in requests/sessions. py: The Session Class: A Session object allows you to:  Persist settings like headers, cookies, and authentication across multiple requests.  Maintain a pool of connections for better performance (connection reuse). Key Attributes of Session:  headers: A default dictionary of headers sent with every request.  cookies: Manages cookies for the session.  auth: Handles authentication (e. g. , HTTP Basic Auth).  adapters: Maps schemes (like http or https) to transport adapters (defined in adapters. py). Session. request Method: The core method that sends a prepared HTTP request. Signature: 12def request(self, method, url, params=None, data=None, headers=None, cookies=None, files=None, auth=None, timeout=None, . . . ):  # Logic to send the requestKey Steps Inside Session. request:  Merge Settings:Combine session-level settings (like headers and cookies) with request-specific settings.   123merged_headers = self. headers. copy()if headers: merged_headers. update(headers)    Prepare the RequestCreate a Request object and prepare it into a PreparedRequest using its prepare method.   1234567891011req = Request( method=method. upper(), url=url, headers=merged_headers, params=params, data=data, cookies=cookies, auth=auth, . . . )prep = req. prepare()    Send the RequestThe prepared request is sent using the send method (delegates to an adapter).   1resp = self. send(prep, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)    Handle ResponseHooks and redirects are processed if applicable. Return the final Response object. Session. send Method: The send method sends a PreparedRequest and returns a Response object. Key Responsibilities:  Determines the appropriate transport adapter (e. g. , HTTPAdapter) based on the request’s URL scheme (http or https).  Calls the adapter’s send method to handle the actual I/O. Example:123def send(self, request, **kwargs):  adapter = self. get_adapter(url=request. url)  return adapter. send(request, **kwargs)Connection Pooling: The Session class uses transport adapters (from adapters. py) for connection pooling and reusing TCP connections, which improves performance for multiple requests to the same host. Example of Using a Session: 1234with requests. Session() as session:  session. headers. update({'Authorization': 'Bearer TOKEN'})  response = session. get('https://api. example. com/data')  print(response. json())The Authorization header is reused for all requests made with the session. The same connection is reused for performance. This is where the magic of persistent settings and efficient networking happens in requests. sessions. py! "
    }, {
    "id": 19,
    "url": "https://vikassharma.me/v1/requests-library-deep-dive-4/",
    "title": "Requests Library Deep Dive - 4",
    "body": "2025/01/09 - Continuing to study the requests module. Today, trying to go through requests/models. py, which defines the foundational classes for representing HTTP requests and responses. Key Concepts in requests/models. py: Core Classes: Two critical classes in this module are:Request: Represents an HTTP request. Response: Represents an HTTP response.  Request ClassThe Request class encapsulates all the data needed to prepare and send an HTTP request. Key Attributes::  method: The HTTP method (e. g. , ‘GET’, ‘POST’).  url: The URL to which the request is made.  headers: A dictionary of HTTP headers.  params: Query parameters for the URL.  data / json: The request payload (body). Example Constructor:12345678def __init__(self, method, url, headers=None, files=None, data=None, params=None, json=None, . . . ):  self. method = method. upper()  self. url = url  self. headers = headers or {}  self. params = params or {}  self. data = data  self. json = json  . . . Preparing a Request: The prepare method converts the Request into a PreparedRequest object, which is a fully-formed request ready to be sent. 12345678910def prepare(self):  return PreparedRequest(). prepare(    method=self. method,    url=self. url,    headers=self. headers,    files=self. files,    data=self. data,    params=self. params,    json=self. json,  ) Response ClassThe Response class holds the result of an HTTP request. Key Attributes:  status_code: The HTTP status code (e. g. , 200, 404).  headers: Response headers.  text: The response body as a string (decoded).  content: The raw response body as bytes.  json: Decodes the response body as JSON (if applicable). Example Constructor:12345678def __init__(self):  self. _content = False  self. status_code = None  self. headers = CaseInsensitiveDict()  self. url = None  self. reason = None  self. elapsed = None  self. history = []Methods:  raise_for_status: Raises an exception for HTTP error responses:  123def raise_for_status(self): if 400 &lt;= self. status_code &lt; 600:   raise HTTPError(f'{self. status_code} Error: {self. reason}')    json: Parses the body as JSON:  12def json(self, **kwargs): return json. loads(self. text, **kwargs)    Interaction Between Request and Response  A Request object is prepared using prepare, resulting in a PreparedRequest. The Session sends the PreparedRequest and receives a Response object. The Response contains all the information about the server’s reply to the request. This module is where a lot of abstraction occurs, making HTTP requests intuitive for end users. "
    }, {
    "id": 20,
    "url": "https://vikassharma.me/v1/python-context-manager/",
    "title": "TIL: Python context manager",
    "body": "2025/01/08 - While reviewing the requests library’s codebase, I found myself diving into yet another rabbit hole. A couple of internet searches later, I had gained some foundational understanding of the concept I encountered, which I decided to capture under my TIL (Things I Learned Today) series. Discovery: __enter__ and __exit__: During my code-reading exercise, I came across two dunder (double underscore) methods: __enter__ and __exit__. These were new to me, but I quickly learned their importance in Python’s built-in Context Manager mechanism. What is a Context Manager?: Context managers in Python are used to manage resources efficiently. They handle the setup and teardown logic required when working with resources such as files, network connections, or database cursors. The with statement is the idiomatic way to use context managers. For example, consider file operations in Python: 12with open('filename') as file:  file. read()Under the hood, the with statement ensures that the file object is properly allocated and released, even if an exception occurs during execution. The equivalent code using try and finally would look like this: 12345file = open('filename')try:  file. read()finally:  file. close()Really amazing to see the amount of boilerplate this reduces. Custom Context Managers: The magic behind context managers lies in the __enter__ and __exit__ methods. By defining these methods in a class, you can create custom context managers. Here’s an example from the requests library, specifically in the sessions. py file: 12345678910class Session:  '''  Omitting other sections for brevity. Refer to the link above  to view the complete code.   '''  def __enter__(self):    return self  def __exit__(self, exc_type, exc_value, traceback):    self. close()This implementation allows the Session class to be used with the with keyword, like so: 12with Session() as session:  return session. request(method=method, url=url, **kwargs)In this example, the __enter__ method initializes the context and returns the Session instance, while the __exit__ method ensures that the session is properly closed, even if an exception occurs. Handling exceptions in __exit__: The __exit__ method can also handle exceptions raised within the context block. Its signature includes three arguments: exc_type: The exception type. exc_value: The exception instance. traceback: The traceback object. If the exit method returns True, it suppresses the exception. Here’s an example: 12345678910111213141516class MyContextManager:  def __enter__(self):    print( Entering context )    return self  def __exit__(self, exc_type, exc_value, traceback):    if exc_type:      print(f Exception caught: {exc_value} )      return True # Suppress the exception    print( Exiting context )# Usagewith MyContextManager() as cm:  print( Inside context )  raise ValueError( Something went wrong! )print( Outside context )12345# OutputEntering contextInside contextException caught: Something went wrong!Outside context"
    }, {
    "id": 21,
    "url": "https://vikassharma.me/v1/requests-library-deep-dive-3/",
    "title": "Requests Library Deep Dive - 3",
    "body": "2025/01/07 - Key Points:: High-Level Structure: The requests library is organized into several core modules that handle different parts of HTTP functionality. Here’s a quick overview:  requests/__init__. pyThis file defines the user-facing API of the library, such as requests. get, requests. post, etc. It imports functionality from other internal modules and exposes them as a unified interface.  requests/models. pyDefines classes like Request and Response, which represent HTTP requests and responses respectively. Handles data serialization, headers, and response content.  requests/sessions. pyManages Session objects, which allow for persistent settings (e. g. , headers, cookies) across multiple requests. Provides methods like Session. get and Session. post.  requests/adapters. pyImplements the HTTPAdapter class, which handles the low-level connection pooling and transports.  requests/api. pyA thin wrapper around Session methods to provide the requests. get, requests. post, etc. , functions.  requests/utils. pyContains helper functions used across the library (e. g. , URL manipulation, encoding detection).  requests/exceptions. pyDefines custom exception classes used by the library (e. g. , RequestException, HTTPError).  requests/status_codes. pymapping of HTTP status codes to their textual representation (e. g. , 200: ‘OK’).  requests/cookies. pyManages cookies for HTTP requests.  requests/hooks. pyImplements hooks, allowing users to customize behavior (e. g. , modifying a response object before it’s returned). "
    }, {
    "id": 22,
    "url": "https://vikassharma.me/v1/requests-library-deep-dive-2/",
    "title": "Requests Library Deep Dive - 2",
    "body": "2025/01/06 - File reviewed: api. py Key Points::  The main function used is request(method, url, **kwargs).  All other methods internally call this function.  The request function’s implementation is straightforward:1234# By using the 'with' statement, we ensure the session is closed, # avoiding open sockets that could trigger a ResourceWarning or appear as a memory leak. with sessions. Session() as session:  return session. request(method=method, url=url, **kwargs) A session instance is created, and the request method is called on it.  Next steps: Study the sessions module. "
    }, {
    "id": 23,
    "url": "https://vikassharma.me/v1/requests-library-deep-dive-1/",
    "title": "Requests Library Deep Dive - 1",
    "body": "2025/01/05 - Continuing my exploration of the requests library, I thought it would be helpful to first review some of its most commonly used APIs before diving into the source code. Here’s a quick overview: Core Methods: The library provides 7 main methods, all of which return an instance of the Response object:    requests. request(method, url, **kwargs)The most flexible method, allowing you to specify the HTTP method (GET, POST, PUT, DELETE, etc. ) and additional parameters.     requests. get(url, params=None, **kwargs)Sends a GET request to the specified URL. Query parameters can be passed as a dictionary to the params argument.     requests. post(url, data=None, json=None, **kwargs)Sends a POST request. You can include form data or JSON in the request body.     requests. put(url, data=None, **kwargs)Sends a PUT request, typically used for updating resources.     requests. patch(url, data=None, **kwargs)Sends a PATCH request for partial updates to a resource.     requests. delete(url, **kwargs)Sends a DELETE request to remove a resource.     requests. head(url, **kwargs)Sends a HEAD request, retrieving only headers without the response body.  Common Parameters: Across these methods, several parameters are frequently used:  url: The target URL for the request.  params: Query parameters, passed as a dictionary (commonly used with GET requests).  data: The body of the request, typically used with POST or PUT.  json: A JSON-serializable object to include in the request body.  headers: Custom HTTP headers to send with the request.  cookies: Cookies to include with the request.  files: Files for multipart file uploads.  auth: Authentication credentials.  timeout: Specifies the maximum time to wait for a response before raising a timeout exception.  allow_redirects: Whether to follow HTTP redirects (defaults to True). This overview serves as a foundation for understanding the requests library before delving into its implementation details. References: https://requests. readthedocs. io/en/latest/api/#main-interface "
    }, {
    "id": 24,
    "url": "https://vikassharma.me/v1/requests-library-deep-dive/",
    "title": "Requests library deep dive series",
    "body": "2025/01/04 - Starting today, I’ll be doing a deep-dive review of the popular Python library, Requests. My goal is to thoroughly explore its codebase and document my observations incrementally in a new category on my blog. I’m calling this series requests-sticky-notes. It will serve as a space for less formal posts — including short text entries, quick notes, or bullet points — specifically related to this exploration. To support this approach, I’m also introducing a broader category called sticky-notes, which will be a repository for quick, unpolished ideas or “quick bites. ” Over time, these notes can be refined or aggregated into more formal and comprehensive articles. In the same spirit, once I’ve accumulated enough material, I plan to consolidate these requests-related notes into a polished, in-depth article. "
    }, {
    "id": 25,
    "url": "https://vikassharma.me/v1/how-i-plan-to-get-consistent-at-writing/",
    "title": "Reflecting on the year 2024",
    "body": "2025/01/03 - Happy New Year 2025! It’s been a while since I posted anything on this blog. In fact, I didn’t manage to publish any articles at all last year. Looking back, I realize there are quite a few drafts still sitting in my _drafts folder, waiting to see the light of day. However, 2024 was quite different, marked by the ups and downs it brought into my life. 2023 will undoubtedly be remembered for the wave of mass layoffs. Unfortunately, my job was also made redundant in November 2023. To say the least, the job market was extremely challenging at that time. However, the unexpected free time made me more appreciative of the small joys in life—things we often overlook in the daily hustle. Then came 2024. I started a new job in an entirely new country—Singapore. At first, I was a bit skeptical about the move. But as time went on, I began to enjoy the work environment and the overall experience. In many ways, last year was about overcoming setbacks and rebuilding my life. Most importantly, it was about regaining a positive outlook. So, part of the reason for not posting anything on the blog can be attributed to the sheer amount of change I was navigating (thankfully, all positive in the end). On the health front, I built some great habits, including running and working out regularly. I think there’s something about Singapore that inspires—or perhaps nudges—you to adopt a healthier lifestyle. Work-wise, it’s been a fulfilling year. I’ve been able to contribute meaningfully toward achieving my team’s goals. On a broader note, I’m very optimistic about the advancements in AI, especially in the realm of large language models. I believe 2025 will be a year of diving deeper into this fascinating field (better late than never, right?). Looking ahead, I also want to be more consistent with posting articles and notes on this blog in 2025. Lately, I’ve been inspired by Simon’s blog, and I hope to emulate some of that regularity and insightfulness. Here’s to hoping for the best. From here, the only way is upwards and onwards. LFG 💪 Happy New Year once again! "
    }, {
    "id": 26,
    "url": "https://vikassharma.me/v1/poems-i-like/",
    "title": "Poems I like",
    "body": "2023/10/30 -                                                 ਵਗਦੇ ਪਾਣੀ              :                             30 Oct 2023                    "
    }, {
    "id": 27,
    "url": "https://vikassharma.me/v1/vagde-paani/",
    "title": "ਵਗਦੇ ਪਾਣੀ",
    "body": "2023/10/30 - Vagde Pani by Dr. Diwan Singh Kalepani ਪਾਣੀ ਵਗਦੇ ਹੀ ਰਹਿਣ,ਕਿ ਵਗਦੇ ਸੁੰਹਦੇ ਨੇ,ਖੜੋਂਦੇ ਬੁੱਸਦੇ ਨੇ,ਕਿ ਪਾਣੀ ਵਗਦੇ ਹੀ ਰਹਿਣ । ਜਿੰਦਾਂ ਮਿਲੀਆਂ ਹੀ ਰਹਿਣ,ਕਿ ਮਿਲੀਆਂ ਜੀਂਦੀਆਂ ਨੇ,ਵਿਛੜਿਆਂ ਮਰਦੀਆਂ ਨੇ,ਕਿ ਜਿੰਦਾਂ ਮਿਲੀਆਂ ਹੀ ਰਹਿਣ । ਰੂਹਾਂ ਉਡਦੀਆਂ ਹੀ ਰਹਿਣ,ਇਹ ਉੱਡਿਆਂ ਚੜ੍ਹਦੀਆਂ ਨੇ,ਅਟਕਿਆਂ ਡਿਗਦੀਆਂ ਨੇ,ਕਿ ਰੂਹਾਂ ਉਡਦੀਆਂ ਹੀ ਰਹਿਣ । ਤੇ ਮੈਂ ਟੁਰਦਾ ਹੀ ਰਹਾਂ,ਕਿ ਟੁਰਿਆਂ ਵਧਦਾ ਹਾਂ,ਖਲੋਇਆਂ ਘਟਨਾ ਹਾਂ,ਕਿ ਹਾਂ, ਮੈਂ ਟੁਰਦਾ ਹੀ ਰਹਾਂ । ~ Dr. Diwan Singh Kalepani "
    }, {
    "id": 28,
    "url": "https://vikassharma.me/v1/how-to-solve-sliding-window-problems/",
    "title": "How to solve Sliding Window Problems",
    "body": "2023/10/25 - Table of Contents:  Introduction How do you identify them? General Mental Model     1. Expand   2. Shrink   3. Record the Candidate Result    Code Template Problem Statement Explanation and Solution Types     Fixed Size Window   Variable Size Window         1. Left Catches Up with Right     2. Multiple Possible Lefts           Difference from Other General Optimizations Where Not to Apply Sliding Window Technique ConclusionIntroduction: Sliding window is a common technique/pattern used to solve many different problems in computer science. In fact, its one of the most frequently asked type of problem during software engineering interviews. This blog post aims to provide clarity about these kind of questions and also aid the readers with necessary tools (mental model and coding templates) needed to efficiently solve the problems involving this technique. How do you identify them?: There are a few key things to look for when identifying problems where the sliding window technique can be applied:  The problem involves a sequence of data points such as arrays, list of elements or string.  Problem is specifically asking about finding some subrange in that array/string, like a longest, shortest or target value.  There is a constraint on the size of the window. Sometimes, it’s as simple as being clearly mentioned as “k-sized window” or little more abstract in nature like “longest substring without repeating characters”. General mental model: At the very fundamental level, sliding window technique involves:  Dividing a sequence of data points into overlapping subsets of fixed size (or variable size based on certain constraint on the window size), and then performing some operation on each subset.  The window is then moved one position to the right, and the operation is performed on the new subset.  This process is repeated until the window reaches the end of the sequence. Let’s try to formalise these fundamental steps as follows: 1. Expand: As the name suggests, in this step we are just trying to expand the window being observed at the right end. While there are few different ways to do that, let’s stick with good old for loop at the moment. We’ll call our iterator as right to mimic the right end of our conceptual window (Sliding window: well it slides on the ends, so nothing fancy) 2. Shrink: As we discussed earlier, there would be some kind of constraint on the size of the window. This constraint can simply be a constraint of let’s say “k-sized window” or little more abstract in nature like “longest substring without repeating characters”. Essentially this constraint/condition will help us to evaluate the validity of the window being observed. This particular step just refers to the action of shrinking the window from its left end towards right so that we can maintain the valid window (that satisfies the constraint on size) 3. Record the candidate result: Once we have a valid window, then all that is left for us is to record the candidate result from the window being observed. In most of the cases, we’ll have no benefit of storing all the possible results in memory. Instead, we’ll often store the best-result-so-far and keep on comparing this so called best-result-so-far with next candidate result of any future windows. Following template captures the above idea at a high level Code template: 1234567891011121314151617def fn(arr):  left, result, cur_win = 0, 0, 0  for right in range(len(arr)):	  # 1. Expand    # do logic here to add arr[right] to curr_win		 # 2. Shrink    while WINDOW_CONDITION_BROKEN:      # keep removing arr[left] from curr_win       # until it is a valid window again      left += 1		 # 3. Record the candidate result    # update result    return resultLet’s quickly solve a simple problem using sliding window pattern to reinforce our learning. Problem statement: You are given an array prices where prices[i] is the price of a given stock on the i-th day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0. Example 1: Input: prices = [7,1,5,3,6,4]Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell. Example 2: Input: prices = [7,6,4,3,1]Output: 0 Explanation: In this case, no transactions are done and the max profit = 0. Explanation and Solution:  We fix a buy price, in this case index=0.  We start with index=0 and start expanding with the next possible selling price.  For each potential selling price, we check if this window is still profitable i. e. prices[sell] &gt;= prices[buy]. If that’s not the case, then it means that we can do better in terms of selecting our buy price.  Therefore, we move our buy price pointer to sell price directly (as we would have processed all intermediate cases already).  This problem is of category Left catches up with right explained later in this post.  Following code implements this logic for more clarity. 123456789101112131415def maxProfit(prices: List[int]) -&gt; int:	buy, maxProfit = 0, 0	for sell in range(len(prices)):		# Expand		# no action needed - we are just expanding our observed window  # by one potential selling price at a time				# Shrink		if prices[sell] &lt; prices[buy]:			buy = sell				# Record candidate result and compare it against best we got so far		maxProfit = max(maxProfit, prices[sell]-prices[buy])return maxProfitTypes: Fixed size window: Example(s):  Sliding window maximumVariable size window: 1. Left catches up with right: Example(s):  Best time to buy and sell stock Longest repeating character replacement Permutation in string2. Multiple possible lefts: Example(s):  Longest substring without repeating characters Minimum window substringDifference from other general optimizations: The sliding window technique offers a specific approach to problem-solving, distinct from other general optimization strategies. It excels in scenarios where you need to efficiently analyze a subset of data. While dynamic programming and other techniques have their strengths, sliding windows are particularly valuable when processing data sequentially. Also, there has to be a constraint on window size. Otherwise, we won’t be able to shrink or expand window linearly. Where not to apply Sliding Window technique: While the sliding window technique is a versatile tool, it’s not always the best choice. Avoid using it in situations where the problem’s requirements do not align with the window concept or when alternative strategies, such as hash tables or prefix sums, are more efficient. Conclusion: In the realm of problem-solving, the sliding window technique stands as a versatile and efficient approach, particularly when dealing with sequences of data. This blog post has shed light on the fundamental principles behind this technique, from identifying suitable problems to constructing a code template for implementation. The key takeaways are:  The sliding window technique involves dividing a sequence into overlapping subsets and iteratively performing operations on these subsets.  It excels in scenarios with constraints on window size, such as finding the longest substring without repeating characters or analyzing stock price trends.  While sliding windows offer a powerful strategy, remember that it’s not a one-size-fits-all solution. Be mindful of situations where alternative techniques like hash tables or dynamic programming might be more effective. By mastering the sliding window technique and recognizing when to apply it, you’ll add a valuable tool to your problem-solving toolkit, making those tricky software engineering interview questions a breeze. So go ahead, slide through those problems and unlock solutions with ease! "
    }, {
    "id": 29,
    "url": "https://vikassharma.me/v1/browser-extensions-that-i-use-in-2023/",
    "title": "Browser extensions that I use in 2023",
    "body": "2023/10/18 -  Bulk Url Opener"
    }, {
    "id": 30,
    "url": "https://vikassharma.me/v1/reactjs-reference-notes/",
    "title": "ReactJs reference notes",
    "body": "2023/10/12 -  Introduction Components     Functional Components   Class Components    JSX (JavaScript XML) Props State Hooks     useState   useEffect   useContext   useRef   Custom Hooks    Rendering Component Communication Styling Virtual DOM React Component Lifecycle     Mounting Phase         constructor()     render()     componentDidMount()          Updating Phase         static getDerivedStateFromProps()     shouldComponentUpdate()     render()     getSnapshotBeforeUpdate()     componentDidUpdate()          Unmounting Phase         componentWillUnmount()          Error Handling         componentDidCatch()          Note    Code lab Useful linksIntroduction: ReactJs is an open-source javascript library for building User interfaces. It’s declarative, efficient and flexible. Components:  Components are the building blocks of React applications.  They are reusable, self-contained, and can be nested within other components.  Components can either be functional or class-based. Functional Components: Simple javascript functions that return React elements (also the recommended way of writing Components). They don’t have state or lifecycle methods, but they can use hooks to add state and side effects. 123const HelloComponent = (props) =&gt; {	return &lt;h1&gt;Hello {props. name}&lt;/h1&gt;;};Class Components: They offer more features such as state and lifecycle methods. 12345678910111213141516171819202122232425262728293031323334class CounterComponent extends React. Component {	constructor(props) {		super(props);		this. state = {			message:  Hello ,			count: 0,		};	}	componentDidMount() {		// runs after the component is mounted on the DOM		console. log( Component did mount );	}	componentWillUnmount() {		// runs before the component is about to unmount from the DOM		console. log( Component will unmount );	}	handleClick() {		this. setState({			count: this. state. count + 1,		});	}	render() {		return (			&lt;div&gt;				&lt;h1&gt;{this. props. name}, current count: {this. state. count}&lt;/h1&gt;				&lt;button onClick={this. handleClick}&gt;Increment&lt;/button&gt;			&lt;/div&gt;		);	}}JSX (JavaScript XML):  JSX allows you to write HTML-like code in JavaScript.  It must be compiled into JavaScript using a tool like Babel. 1const element = &lt;h1&gt;Hello, React!&lt;/h1&gt;;Props:  Props are Immutable data passed from parent to child components. They’re used to configure the behaviour of a component.  Access using props in functional components or this. props in class components. 1234567function MyComponent(props) {	return &lt;h1&gt;{props. name}&lt;/h1&gt;;}const App = () =&gt; {	return &lt;MyComponent name= John Doe  /&gt;;};State:  State is a private data store that is associated with a React component.  Manage component-specific data that can change over time.  Use useState hook or this. state in class components. 1234567891011121314151617181920class MyComponent extends React. Component { state = {  count: 0, }; handleClick = () =&gt; {  this. setState({   count: this. state. count + 1,  }); }; render() {  return (   &lt;div&gt;    &lt;h1&gt;{this. state. count}&lt;/h1&gt;    &lt;button onClick={this. handleClick}&gt;Increment&lt;/button&gt;   &lt;/div&gt;  ); }}Hooks: React Hooks are functions that allow you to “hook into” React state and lifecycle features in function components. They provide a way to manage state and side-effects without using class components. useState:  Allows functional components to manage state.  Takes an initial state value as an argument and returns an array with two elements: the current state value and a function to update it.  Example:123456789101112import React, { useState } from 'react';function Counter() { const [count, setCount] = useState(0); return (  &lt;div&gt;   &lt;p&gt;Count: {count}&lt;/p&gt;   &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;  &lt;/div&gt; );}useEffect:  Performs side-effects in function components.  Takes a function that contains the code for side effects and an optional array of dependencies.  Only runs the function if any of the dependencies have changed.  Example:1234567891011121314151617import React, { useState, useEffect } from 'react';function Timer() { const [seconds, setSeconds] = useState(0); useEffect(() =&gt; {  const intervalId = setInterval(() =&gt; {   setSeconds(seconds + 1);  }, 1000);  return () =&gt; {   clearInterval(intervalId);  }; }, [seconds]); return &lt;p&gt;Seconds: {seconds}&lt;/p&gt;;}useContext:  Accesses the context value created by React. createContext.  Allows components to consume context without introducing a component tree nesting.  It consists of two parts:     a context provider that provides the data, and a context consumer that consumes the data.    The useContext() hook takes a context object as an argument and returns the current value of that context.     Example:123456789import React, { useContext } from 'react';const MyContext = React. createContext();function MyComponent() { const contextValue = useContext(MyContext); return &lt;p&gt;Context Value: {contextValue}&lt;/p&gt;;}useReducer:  Manages complex state logic by using a reducer function.  Similar to useState, but with more control over state updates.  Example:1234567891011121314151617181920212223242526import React, { useReducer } from 'react';const initialState = { count: 0 };function reducer(state, action) { switch (action. type) {  case 'increment':   return { count: state. count + 1 };  case 'decrement':   return { count: state. count - 1 };  default:   return state; }}function Counter() { const [state, dispatch] = useReducer(reducer, initialState); return (  &lt;div&gt;   &lt;p&gt;Count: {state. count}&lt;/p&gt;   &lt;button onClick={() =&gt; dispatch({ type: 'increment' })}&gt;Increment&lt;/button&gt;   &lt;button onClick={() =&gt; dispatch({ type: 'decrement' })}&gt;Decrement&lt;/button&gt;  &lt;/div&gt; );}useRef:  Takes an initial value as an argument and returns an object with a current property that points to the current value of the reference.  Creates a mutable ref object to interact with DOM elements or store mutable values.  Does not cause re-renders when the ref value changes.  Example:12345678910111213141516import React, { useRef } from 'react';function InputWithFocus() { const inputRef = useRef(); const focusInput = () =&gt; {  inputRef. current. focus(); }; return (  &lt;div&gt;   &lt;input ref={inputRef} type= text  /&gt;   &lt;button onClick={focusInput}&gt;Focus Input&lt;/button&gt;  &lt;/div&gt; );}Custom Hooks:  Allows you to create reusable hooks to encapsulate logic.  Typically start with the word “use” to indicate that it’s a hook.  Example:123456789101112131415161718192021222324252627282930import { useState, useEffect } from 'react';function useLocalStorage(key, initialValue) { const [value, setValue] = useState(() =&gt; {  const storedValue = localStorage. getItem(key);  return storedValue ? JSON. parse(storedValue) : initialValue; }); useEffect(() =&gt; {  localStorage. setItem(key, JSON. stringify(value)); }, [key, value]); return [value, setValue];}// Usagefunction App() { const [name, setName] = useLocalStorage('name', 'Guest'); return (  &lt;div&gt;   &lt;p&gt;Hello, {name}&lt;/p&gt;   &lt;input    type= text     value={name}    onChange={(e) =&gt; setName(e. target. value)}   /&gt;  &lt;/div&gt; );}Rendering:  To render a component, we need to use ReactDOM. render() method, which takes two arguments: the component to render and the DOM element where to render it. 1ReactDOM. render(&lt;Hello name= World  /&gt;, document. getElementById( root )); To use a component inside another component, we need to use it as a JSX element with its name as a tag. We can also pass props to it as attributes.  For example, if we want to use our Hello component inside another component called App, we can write something like this:123456789function App() { return (  &lt;div&gt;   &lt;Hello name= Alice  /&gt;   &lt;Hello name= Bob  /&gt;   &lt;Hello name= Charlie  /&gt;  &lt;/div&gt; );}Component Communication:  Parent to Child: Pass data via props.  Child to Parent: Callback functions passed as props. Styling:  Inline styles: Use style attribute.  CSS Modules, Styled Components, or popular CSS frameworks. Virtual DOM:  The Virtual DOM is a lightweight in-memory representation of the actual DOM. It’s used by React to optimize the process of updating the user interface.  When there’s a change in the application’s state, React creates a new Virtual DOM tree.  React then compares this new Virtual DOM tree with the previous one to identify the differences (diffing).  The differences are used to update the real DOM, but only the parts that changed.  This minimizes the number of updates and improves performance. Reconciliation: Reconciliation Process::  React’s process of updating the real DOM based on changes in the Virtual DOM is called reconciliation.  It ensures that the user interface is always in sync with the application’s state. Keys in Reconciliation::  Use unique keys for each element in lists to help React identify elements more efficiently.  Keys assist in minimizing unnecessary updates and re-renders. React Component Lifecycle: Mounting Phase: constructor():  Constructor is called when a component instance is created.  Initialize state and bind methods in the constructor. render():  Render method returns the JSX that represents the component’s UI.  It’s a pure function that should not modify the component’s state. componentDidMount():  Invoked after the component is rendered.  Ideal for setting up side effects, such as data fetching or subscribing to events. Updating Phase: static getDerivedStateFromProps():  Rarely used, but if necessary, it’s used to update state based on props. shouldComponentUpdate():  Determines whether the component should re-render.  Return true if you want to update, false to skip re-rendering. render():  Re-render the component with updated props or state. getSnapshotBeforeUpdate():  Allows you to capture some information before the component updates.  Use it with componentDidUpdate to handle interactions with the DOM. componentDidUpdate():  Invoked after the component updates and the changes are reflected in the DOM.  Ideal for performing side effects when props or state change. Unmounting Phase: componentWillUnmount():  Called before a component is removed from the DOM.  Perform cleanup tasks such as canceling timers or unsubscribing from data sources. Error Handling: componentDidCatch():  Captures errors in the child components during rendering.  Implement this method to gracefully handle errors and display fallback UI. Note::  React has moved away from some lifecycle methods in favor of hooks like useEffect.  Focus on class component lifecycle for existing codebases and legacy support. Code lab:  Created this very simple react app to revise the basics.  https://github. com/vikas3045/task-managerUseful links:  https://react. dev/reference/react/ https://create-react-app. dev/"
    }, {
    "id": 31,
    "url": "https://vikassharma.me/v1/leetcode-121-best-time-to-buy-and-sell-stock/",
    "title": "121. Best Time to Buy and Sell Stock",
    "body": "2023/09/18 -       You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.   1234567891011121314151617Example 1:Input: prices = [7,1,5,3,6,4]Output: 5Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell. Example 2:Input: prices = [7,6,4,3,1]Output: 0Explanation: In this case, no transactions are done and the max profit = 0. Constraints:1 &lt;= prices. length &lt;= 1050 &lt;= prices[i] &lt;= 104Intuition: First thoughts: In order to solve this question in a brute-force way, we’ll have to:  loop through all the elements and for each element (i. e. selecting the current element as our buying price):     we need to check against all the possible selling points (i. e. all the prices after our chosen buying price).          calculate if we are going to make any profit with the pair of chosen buy price and sell price. Record that in higher level variable (let’s call it max_profit - only need to store the maximum obtained so far)           by end of the first loop, we’ll have our answer recorded in the higher level variable max_profit. This approach has:  run time complexity of O(n2) (as we have nested loops).  space complextity of O(1) (since our storage needs doesn’t grow with input size i. e. size of the allocated variable max_profit is going to be same for any input size). Further thoughts: Can we do better than O(n2)?  In our brute-force approach, for each potential buying price, we are eventually looking for the best possible selling price. The inefficiency in this approach is that it keeps looking for the selling price, even if our current profit becomes 0 or -ve at certain point. We know for sure that for such cases, our chosen buying price can’t really be the solution to our problem as a better buying price exists at later stage due to which the profit becomes either 0 or -ve.  Let’s consider an example prices = [7,2,5,1,3,6,4]. Assume that we are at day 2 (price=2, index=1). Now, while looking for potential selling prices, at some point in time, we would consider selling at day 4 (price=1, index=3). At that point the current profit would have been become -1. Which essentially means that there is no point in considering our current buying price (index=1) because either same or better buying price exists at later stage. So, we can safely ignore the intermediate buying prices and directly move to index=3.  From there on, we can keep looking for the optimal selling price:     till we run out of all potential prices.     At each valid selling point, we record the candidate result in the higher level variable max_profit (only if we find any better result from the previously computed candidates).  If we stumble upon a situation where we encounter -ve profit, we ignore looking any further and we move to next possible buying price. Final approach:  Initialize a varible namely max_profit with current value as 0.  Loop through all the elements of given array.      keep looking for potential selling prices, till the computed profit so far is &gt;= 0.    otherwise, (i. e. current profit gets -ve):         Move to the current selling price being considered.           while we keep getting +ve result store the max of max_profit and current profit in the variable max_profit.     By end of the main loop we would have gotten our result in the variable max_profit. Time to just return it.  Time complexity: O(n) (since we only process all the elements at max 2 times).  Space complexity: O(1) (since our auxiliary storage max_profit doesn’t grow with input size). Python code: 123456789101112131415161718192021222324252627class Solution:  def maxProfit(self, prices: List[int]) -&gt; int:    max_profit, buy_price_idx, sell_price_idx = 0, 0, 0    while sell_price_idx &lt; len(prices):      current_profit = prices[sell_price_idx] - prices[buy_price_idx]      if current_profit &gt;= 0:        max_profit = max(max_profit, current_profit)        sell_price_idx += 1      else:        buy_price_idx = sell_price_idx    return max_profit# Alternative thinking model in terms of sliding windowclass Solution:  def maxProfit(self, prices: List[int]) -&gt; int:    buy, maxProfit = 0, 0        for sell in range(len(prices)):      # expand      # record candidate result if window is valid      if prices[buy] &lt;= prices[sell]:        maxProfit = max(maxProfit, prices[sell]-prices[buy])                    # shrink      if prices[sell] &lt; prices[buy]:        buy = sell    return maxProfit"
    }, {
    "id": 32,
    "url": "https://vikassharma.me/v1/leetcode-217-contains-duplicate/",
    "title": "217. Contains Duplicate",
    "body": "2023/09/16 -   Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct. 123456789101112131415Example 1:Input: nums = [1,2,3,1]Output: trueExample 2:Input: nums = [1,2,3,4]Output: falseExample 3:Input: nums = [1,1,1,3,3,4,3,2,4,2]Output: trueConstraints:1 &lt;= nums. length &lt;= 105-109 &lt;= nums[i] &lt;= 109Intuition: First thoughts: In order to solve this question in a brute-force manner, we’ll have to:  loop through all the elements and for each element     we need to check against all the remaining elements if that element is present or not.    This approach has:  run time complexity of O(n**2) (as we have nested loops) space complextity of O(1) (since we don’t need to allocate any extra storage)Further thoughts: Can we do better than O(n**2)?  Well, if we use hash set to store all the elements of the given array, then we should be able to check the existence of any element in constant time.  Thus, we can just loop through all the elements and then for each element we can check in constant time whether the element exists or not. Final approach:  Initialize an empty hashset by name lookup Loop through all the elements of given array     if that element is not present in lookup, then let’s add it and move ahead   otherwise, (i. e. element already exists, duplicated spotted!)         return True           return False, as we exhausted the given array and didn’t find any duplicate.  Time complexity: O(n) (since we only process elements in a single loop) Space complexity: O(n) (since we create a new hashset to store all the elements of given array)Python code: 12345678class Solution:  def containsDuplicate(self, nums: List[int]) -&gt; bool:    lookup = set()    for x in nums:      if x in lookup:        return True      lookup. add(x)    return False"
    }, {
    "id": 33,
    "url": "https://vikassharma.me/v1/regex-with-python/",
    "title": "Understanding Regular Expressions in Python",
    "body": "2023/03/22 - Regular expressions, often abbreviated as regex, are a powerful tool used to match patterns in strings. They are widely used in various programming languages, including Python, for various purposes such as searching for specific characters, validating inputs, and parsing data. In this blog post, we will dive into the world of regex in Python and understand how to use them to accomplish a range of tasks. What are Regular Expressions?: A regular expression is a sequence of characters that define a search pattern. These patterns can be used to search, match, and manipulate text data. For example, a regular expression could be used to search for a specific pattern of characters in a string, such as email addresses, URLs, or phone numbers. Using Regular Expressions in Python: In Python, the re module provides a number of functions for working with regular expressions. Some of the most commonly used functions in the re module are:  search(): This function searches for a match in a string and returns a match object if there is a match.  findall(): This function returns all non-overlapping matches as a list of strings.  split(): This function splits a string into a list of substrings based on the specified pattern.  sub(): This function replaces all occurrences of a specified pattern in a string with a replacement string. Regular Expression Syntax: The syntax for regular expressions in Python is similar to that used in other programming languages. Some of the most commonly used regular expression syntax include:  Literals: A literal is a character that matches itself. For example, the pattern  a  will match the letter  a  in the string.  Meta-characters: Meta-characters are characters with a special meaning in regular expressions. For example, the dot (. ) matches any character except a newline, and the asterisk (*) matches zero or more occurrences of the preceding character.  Character Classes: Character classes define a set of characters that can match a single character in the string. For example, the pattern  [aeiou]  will match any vowel.  Quantifiers: Quantifiers specify the number of times a pattern should be repeated. For example, the pattern  a{3}  will match the string  aaa .  Anchors: Anchors are special characters that match a position in the string rather than a character. For example, the caret (^) matches the start of a line, and the dollar sign ($) matches the end of a line.  Escape sequences: To match a character having special meaning in regex, you need to use a escape sequence prefix with a backslash (\). E. g. , \.  matches  .  ; regex \+matches  + ; and regex \( matches  ( . Examples of Using Regular Expressions in Python: Let’s see some examples of how regular expressions can be used in Python:  Searching for a Pattern:123456import restring =  Hello, my email is test@example. com pattern =  [a-zA-Z0-9. _%+-]+@[a-zA-Z0-9. -]+\. [a-zA-Z]{2,} match = re. search(pattern, string)print( Email: , match. group())In this example, we are using the search() function to find an email address in a string. The pattern used in this example is a commonly used pattern for matching email addresses.  Replacing a Pattern:1234567import restring =  The cat is black and white pattern =  cat replacement =  dog new_string = re. sub(pattern, replacement, string)print(new_string) Extracting All Matches:123456import restring =  The cats are black and white, and the dogs are brown and black pattern =  black matches = re. findall(pattern, string)print( Matches: , matches)In this example, we are using the findall() function to extract all occurrences of the word “black” in a string. The findall() function returns a list of all non-overlapping matches in the string.  Splitting a String:123456import restring =  The cats are black and white, and the dogs are brown and black pattern =  and words = re. split(pattern, string)print( Words: , words)In this example, we are using the split() function to split a string into a list of words based on the pattern “and”. The split() function returns a list of substrings that were separated by the specified pattern.  Replacing Multiple Occurrences:123456import restring =  The cats are black and white, and the dogs are brown and black pattern =  and new_string = re. sub(pattern,  &amp; , string)print( New String: , new_string)In this example, we are using the sub() function to replace all occurrences of the word “and” with “&amp;”. The sub() function replaces all occurrences of the specified pattern in the string with a replacement string. These are just a few examples of the many things that you can do with regular expressions in Python. Regular expressions can be used for a wide range of tasks, from simple text processing to complex data parsing. With a little practice and patience, you can master the art of regex in Python and unleash its full potential! Conclusion: Regular expressions are a powerful tool that can be used to search, match, and manipulate text data in Python. They can be used for a variety of purposes, including searching for specific characters, validating inputs, and parsing data. By understanding the syntax and functions provided by the re module in Python, you can take advantage of the power and flexibility of regular expressions to solve a wide range of programming challenges. "
    }, {
    "id": 34,
    "url": "https://vikassharma.me/v1/how-to-create-blog-with-jekyll-and-github-pages/",
    "title": "How to create blog with Jekyll and Github pages",
    "body": "2022/11/12 - If you always wanted to start your blog and don’t know where to start. Well, just follow this quick guide and by the end of this article, you’ll have your own working blog live on internet (sounds easy right, well it is actually easy. Let’s get to it!). In this guide, we’ll go through the steps to bring our exciting blog to life (yay!!)  Step 1 - Create GitHub account (in case you already don’t have one) and create a public repository to host our blog’s code. (We’ll use GitHub Pages to host our blog for Free, exciting right!).  Step 2 - Set up Jekyll (a tool to generate static sites using markdown syntax) in your computer. By end of this step, our blog should be up and running.  Step 3 - (By the way, this is an optional step) If you have your own domain, we’ll configure DNS settings to point it to our newly created blog. Create GitHub Pages repository Create GitHub account (in case you already don’t have one).  Create a new repository            Name your repository as &lt;github-username&gt;. github. io (well this is important, other names won’t work here. ) Set the visibility of this repository as public and choose Jekyll template for your . gitignore file as shown below.            Setup and configure JekyllRequirements:  Ruby version 2. 5. 0 or higher, including all development headers (check your Ruby version using ruby -v) RubyGems (check your Gems version using gem -v) GCC and Make (check versions using gcc -v,g++ -v, and make -v)Installation: For detailed install instructions, follow the guide for your operating system.  macOS Ubuntu Other Linux WindowsInstall Jekyll: After installing Ruby with chruby, let’s install the latest jekyll and bundle gems: 1$ gem install jekyll bundlerCreate site with Jekyll:  Clone the newly created repository to your local computer. (see if you can give some link for cloning) Open terminal in the directory where you just cloned the github repository.   12$ cd REPOSITORY-NAME# Changes the working directory    Create new jekyll site by running following command  12$ jekyll new . #  .   tells jekyll utility to create new site in current directory    Now, it’s time to see our new blog in our local computer.   1$ bundle exec jekyll serve    If everything went well then you should see the following output. Trying running the url http://127. 0. 0. 1:4000/. If you’re getting some error then try the next step.   12    Server address: http://127. 0. 0. 1:4000/  Server running. . . press ctrl-c to stop.     [Optional step] Open &lt;Parent Repo folder&gt;/Gemfile in text editor of your choice and and add following line.   1gem  webrick ,  ~&gt; 1. 7     [Optional step] Install the gems from Gemfile by running following command.   1$ bundle    Commit your changes to git repo and push these changes to remote branch. GitHub pages - publish settings:  Go to GitHub and open the repository that we created earlier and go to Settings tab as shown below.             Go to Pages section.             Under the section Build and deployment, make sure to select Source as Deploy from a branch. Select main and /root in branch settings.            Congratulations 👏, your blog is live at https://&lt;username&gt;. github. io [Optional] Configure custom domainWell, if you already have your own domain or planning to have one, then following steps might interest you.  Go to Manage DNS section of your domain provider.  Add following DNS records with exact same values.             Add another record with Type=CNAME, Name=www and Data=&lt;username. github. io&gt; Under Settings &gt; Pages &gt; Custom Domain add your domain name (e. g. example. com) and click on Save. That’s it, we’re done with setup here :) Your custom domain should now point to your newly created blog. ConclusionI hope you’re able to successfully set up your blog by following the instructions given in this post. Do let me know in comments, if you find it useful. I’ll try my best to help with any issues that you might face during this setup. Cheers folks! References https://jekyllrb. com/docs/step-by-step/01-setup/ https://docs. github. com/en/pages/setting-up-a-github-pages-site-with-jekyll/creating-a-github-pages-site-with-jekyll"
    }, {
    "id": 35,
    "url": "https://vikassharma.me/v1/hello-world/",
    "title": "Hello world!",
    "body": "2022/10/18 - Excited to share my thoughts here. It’s my birthday today and I thought it would be a good time to start something new and exciting. Hoping to share my experiences (mostly tech related) here. Cheers,Vikas "
    }];

var idx = lunr(function () {
    this.ref('id')
    this.field('title')
    this.field('body')

    documents.forEach(function (doc) {
        this.add(doc)
    }, this)
});
function lunr_search(term) {
    document.getElementById('lunrsearchresults').innerHTML = '<ul></ul>';
    if(term) {
        document.getElementById('lunrsearchresults').innerHTML = "<p>Search results for '" + term + "'</p>" + document.getElementById('lunrsearchresults').innerHTML;
        //put results on the screen.
        var results = idx.search(term);
        if(results.length>0){
            //console.log(idx.search(term));
            //if results
            for (var i = 0; i < results.length; i++) {
                // more statements
                var ref = results[i]['ref'];
                var url = documents[ref]['url'];
                var title = documents[ref]['title'];
                var body = documents[ref]['body'].substring(0,160)+'...';
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><br /><span class='body'>"+ body +"</span><br /><span class='url'>"+ url +"</span></a></li>";
            }
        } else {
            document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>No results found...</li>";
        }
    }
    return false;
}

function lunr_search(term) {
    $('#lunrsearchresults').show( 400 );
    $( "body" ).addClass( "modal-open" );
    
    document.getElementById('lunrsearchresults').innerHTML = '<div id="resultsmodal" class="modal fade show d-block"  tabindex="-1" role="dialog" aria-labelledby="resultsmodal"> <div class="modal-dialog shadow-lg" role="document"> <div class="modal-content"> <div class="modal-header" id="modtit"> <button type="button" class="close" id="btnx" data-dismiss="modal" aria-label="Close"> &times; </button> </div> <div class="modal-body"> <ul class="mb-0"> </ul>    </div> <div class="modal-footer"><button id="btnx" type="button" class="btn btn-danger btn-sm" data-dismiss="modal">Close</button></div></div> </div></div>';
    if(term) {
        document.getElementById('modtit').innerHTML = "<h5 class='modal-title'>Search results for '" + term + "'</h5>" + document.getElementById('modtit').innerHTML;
        //put results on the screen.
        var results = idx.search(term);
        if(results.length>0){
            //console.log(idx.search(term));
            //if results
            for (var i = 0; i < results.length; i++) {
                // more statements
                var ref = results[i]['ref'];
                var url = documents[ref]['url'];
                var title = documents[ref]['title'];
                var body = documents[ref]['body'].substring(0,160)+'...';
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><br /><small><span class='body'>"+ body +"</span><br /><span class='url'>"+ url +"</span></small></a></li>";
            }
        } else {
            document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>Sorry, no results found. Close & try a different search!</li>";
        }
    }
    return false;
}
    
$(function() {
    $("#lunrsearchresults").on('click', '#btnx', function () {
        $('#lunrsearchresults').hide( 5 );
        $( "body" ).removeClass( "modal-open" );
    });
});